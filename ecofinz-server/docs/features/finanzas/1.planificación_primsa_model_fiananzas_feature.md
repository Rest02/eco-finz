# Planificación de Modelos de Datos: Módulo de Finanzas

Este documento detalla la arquitectura de la base de datos para el módulo de finanzas de la aplicación EcoFinz, utilizando Prisma como ORM. El diseño aquí presentado es el resultado de un análisis iterativo para asegurar una base sólida, escalable y robusta para la primera versión de la funcionalidad.

## 1. Esquema de Prisma Final

El siguiente esquema representa la estructura de datos completa y acordada para las funcionalidades de Cuentas, Transacciones, Presupuestos y Resúmenes Mensuales.

```prisma
// --- Enums ---
enum TransactionType {
  INGRESO
  EGRESO
  AHORRO
}

enum AccountType {
  BANCO
  EFECTIVO
  TARJETA_CREDITO
  BILLETERA_DIGITAL
}

// --- Modelos ---

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String
  
  accounts         Account[]
  categories       Category[]
  monthlySummaries MonthlySummary[]
  transactions     Transaction[]
  budgets          Budget[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id        String      @id @default(cuid())
  name      String
  type      AccountType
  balance   Decimal     @default(0.0) @db.Decimal(10, 2)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  transactions Transaction[]

  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

model MonthlySummary {
  id     String @id @default(cuid())
  month  Int
  year   Int
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  transactions Transaction[]
  budgets      Budget[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, month, year])
}

model Category {
  id     String @id @default(cuid())
  name   String
  type   TransactionType
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  transactions Transaction[]
  budgets      Budget[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, name, type])
}

model Transaction {
  id          String   @id @default(cuid())
  amount      Decimal  @db.Decimal(10, 2)
  type        TransactionType
  description String
  date        DateTime

  user        User     @relation(fields: [userId], references: [id], onDelete: NoAction)
  userId      String
  
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  categoryId  String

  account     Account  @relation(fields: [accountId], references: [id], onDelete: Restrict)
  accountId   String

  monthlySummary   MonthlySummary @relation(fields: [monthlySummaryId], references: [id], onDelete: Cascade)
  monthlySummaryId String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Budget {
  id          String  @id @default(cuid())
  name        String
  description String?
  amount      Decimal @db.Decimal(10, 2)

  user        User    @relation(fields: [userId], references: [id], onDelete: NoAction)
  userId      String
  
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId  String
  
  monthlySummary   MonthlySummary @relation(fields: [monthlySummaryId], references: [id], onDelete: Cascade)
  monthlySummaryId String
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

## 2. Análisis de Deficiencias y Consideraciones Futuras

El esquema actual es robusto para una V1, pero es crucial ser conscientes de sus limitaciones y de las complejidades que surgirán al querer implementar características más avanzadas.

### 2.1. Transferencias Entre Cuentas

*   **El Desafío:** Mover dinero entre dos cuentas propias (ej. Banco -> Efectivo).
*   **La Deficiencia Actual:** El modelo no tiene un concepto de "Transferencia". Se debe registrar como dos transacciones separadas (un `EGRESO` y un `INGRESO`) que no están vinculadas a nivel de base de datos. Esto delega la responsabilidad de mantener la consistencia enteramente a la lógica de la API, lo cual es frágil.
*   **Posible Solución Futura:** Introducir un modelo `Transfer` que actúe como un registro padre y enlace las dos transacciones involucradas.

### 2.2. Manejo Avanzado de Deudas y Tarjetas de Crédito

*   **El Desafío:** Las tarjetas de crédito tienen un ciclo de vida complejo (fechas de corte, fechas de pago, intereses, etc.).
*   **La Deficiencia Actual:** El modelo actual trata una tarjeta de crédito como una cuenta más con saldo negativo. No comprende el concepto de "factura" o "estado de cuenta", por lo que no puede realizar cálculos de intereses ni gestionar recordatorios de pago de forma nativa.
*   **Posible Solución Futura:** Crear un modelo `CreditCardStatement` o añadir campos de configuración específicos al modelo `Account` cuando el tipo sea `TARJETA_CREDITO`.

### 2.3. Transacciones y Presupuestos Recurrentes

*   **El Desafío:** Automatizar el registro de operaciones fijas y periódicas (salarios, alquiler, suscripciones).
*   **La Deficiencia Actual:** Todas las transacciones y presupuestos deben ser creados manualmente por el usuario cada vez que ocurren, lo cual es tedioso y propenso a olvidos.
*   **Posible Solución Futura:** Crear modelos `RecurringTransaction` y `RecurringBudget` que sirvan como plantillas y, mediante un proceso automático en el servidor (cron job), generen los registros correspondientes en las fechas programadas.

### 2.4. Inversiones y Activos de Valor Variable

*   **El Desafío:** Registrar y seguir el valor de activos como acciones o criptomonedas, cuyo valor fluctúa.
*   **La Deficiencia Actual:** El esquema está diseñado para gestionar **flujo de caja (cash flow)**, no **patrimonio neto (net worth)**. Puede registrar la compra de un activo, pero no puede seguir su valor de mercado a lo largo del tiempo.
*   **Posible Solución Futura:** Requeriría un ecosistema de modelos completamente nuevo (`Asset`, `AssetPriceHistory`, `Portfolio`), representando una expansión mayor de la aplicación.

## 3. Conclusión

El esquema de datos definido es el punto de partida ideal para la primera versión del módulo de finanzas. Resuelve las necesidades fundamentales de registro de ingresos, egresos, ahorros, presupuestos y manejo de saldos por cuenta de una manera limpia y eficiente.

Las deficiencias identificadas no son bloqueantes para una V1, sino que constituyen un **roadmap claro de características para futuras iteraciones**. La recomendación es proceder con la implementación del esquema actual y abordar estas complejidades en versiones posteriores del producto.

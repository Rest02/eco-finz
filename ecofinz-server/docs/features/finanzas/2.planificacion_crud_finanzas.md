# Plan de Implementación: Módulo de Finanzas (CRUD)

Este documento detalla el plan de acción para desarrollar el módulo de finanzas del backend, implementando las operaciones CRUD (Crear, Leer, Actualizar, Borrar) para los modelos de base de datos ya definidos.

### 1. Buenas Prácticas y Calidad de Código

-   **Principios SOLID:** Se seguirá una arquitectura que respete los principios SOLID para garantizar un código mantenible, escalable y robusto.
-   **Estructura del Proyecto:** Se mantendrá la estructura organizada y modular de NestJS, agrupando la lógica por funcionalidad.
-   **Evitar Redundancia (DRY):** Se reutilizará la lógica de negocio a través de servicios y se crearán utilidades compartidas para evitar la duplicación de código.
-   **Código Limpio:** Se escribirá código claro, legible y auto-documentado.

### 2. Interacción con la Consola

La ejecución de comandos en la terminal (NestJS CLI, git, etc.) será responsabilidad exclusiva del **usuario/desarrollador**. La IA actuará como un asistente: proporcionará los comandos exactos que deben ejecutarse y explicará su propósito. La IA esperará la confirmación del usuario de que el comando se ha ejecutado correctamente antes de continuar con el siguiente paso.

### 3. Contexto del Proyecto

El objetivo de esta planificación es construir el soporte de backend completo para la funcionalidad de finanzas de la aplicación **EcoFinz**. Partiendo de los modelos de Prisma ya definidos (`Category`, `Account`, `Transaction`, `Budget`, `MonthlySummary`), se implementarán los endpoints de la API necesarios para que una aplicación cliente pueda gestionar todos los aspectos de las finanzas personales de un usuario de forma segura.

---

### Flujo de Implementación

1.  **Implementación por Fases:** El desarrollo se realizará fase por fase, según lo delineado a continuación.
2.  **Revisión del Usuario:** Al completar todas las tareas de una fase, la IA informará al usuario que la fase ha concluido. El usuario deberá revisar los cambios implementados (nuevos archivos, modificaciones, etc.).
3.  **Ciclo de Corrección:** Si el usuario encuentra errores o solicita cambios, la IA realizará las correcciones necesarias dentro de esa misma fase hasta que el usuario dé su aprobación.
4.  **Avance:** Una vez que el usuario apruebe los cambios de una fase, se procederá con la siguiente.

---

### **Fase 0: Estructura Inicial del Módulo**

-   [x] Tarea 1: Crear el módulo principal `FinanceModule` que contendrá toda la lógica.
-   [x] Tarea 2: Generar los archivos base `finance.service.ts` y `finance.controller.ts` dentro del nuevo módulo.
-   [x] Tarea 3: Importar `PrismaModule` en `FinanceModule` para proveer acceso a la base de datos a los servicios.
-   [x] Tarea 4: Importar el nuevo `FinanceModule` en el `AppModule` principal para integrarlo a la aplicación.

---

### **Fase 1: CRUD para `Category` (Categorías)**

-   [x] Tarea 1: Generar el recurso para `Category` usando la CLI de NestJS (`controller`, `service`, y `dto`).
-   [x] Tarea 2: Implementar el DTO `CreateCategoryDto` y `UpdateCategoryDto` con las validaciones correspondientes.
-   [x] Tarea 3: Implementar el método `createCategory` en el servicio y su endpoint `POST /categories`, asociando la categoría al usuario autenticado.
-   [x] Tarea 4: Implementar el método `findAllCategories` para obtener solo las categorías del usuario autenticado (`GET /categories`).
-   [x] Tarea 5: Implementar el método `updateCategory` y su endpoint (`PATCH /categories/:id`).
-   [x] Tarea 6: Implementar el método `deleteCategory` y su endpoint (`DELETE /categories/:id`).
-   [x] Tarea 7: Aplicar el guard `JwtAuthGuard` a todas las rutas del `CategoryController`.

---

### **Fase 2: CRUD para `Account` (Cuentas)**

-   [x] Tarea 1: Generar el recurso para `Account` (controller, service, y DTOs).
-   [x] Tarea 2: Implementar `CreateAccountDto` y `UpdateAccountDto` con sus validaciones.
-   [x] Tarea 3: Implementar el método `createAccount` (`POST /accounts`), asociando la cuenta al usuario autenticado.
-   [x] Tarea 4: Implementar `findAllAccounts` para obtener las cuentas del usuario (`GET /accounts`).
-   [x] Tarea 5: Implementar `updateAccount` (`PATCH /accounts/:id`).
-   [x] Tarea 6: Implementar `deleteAccount` (`DELETE /accounts/:id`).
-   [x] Tarea 7: Proteger todas las rutas del `AccountController` con `JwtAuthGuard`.

---

### **Fase 3: CRUD para `Transaction` (Transacciones)**

-   [] Tarea 1: Generar el recurso para `Transaction`.
-   [] Tarea 2: Implementar `CreateTransactionDto` y `UpdateTransactionDto`. El DTO de creación debe incluir `amount`, `type`, `date`, `accountId` y `categoryId`.
-   [] Tarea 3: Implementar `createTransaction` (`POST /transactions`). La lógica debe verificar que `accountId` y `categoryId` pertenezcan al usuario.
-   [] Tarea 4: Implementar `findAllTransactions` (`GET /transactions`) con soporte para filtros (rango de fechas, cuenta, categoría) y paginación.
-   [] Tarea 5: Implementar `findOneTransaction` (`GET /transactions/:id`).
-   [] Tarea 6: Implementar `updateTransaction` (`PATCH /transactions/:id`).
-   [] Tarea 7: Implementar `deleteTransaction` (`DELETE /transactions/:id`).
-   [] Tarea 8: Asegurar que toda la lógica de servicio valide que el usuario solo puede afectar sus propias transacciones.

---

### **Fase 4: CRUD para `Budget` (Presupuestos)**

-   [] Tarea 1: Generar el recurso para `Budget`.
-   [] Tarea 2: Implementar `CreateBudgetDto` y `UpdateBudgetDto`. El DTO necesita `amount`, `month`, `year` y `categoryId`.
-   [] Tarea 3: Implementar `createBudget` (`POST /budgets`), validando que la categoría pertenece al usuario.
-   [] Tarea 4: Implementar `findAllBudgets` (`GET /budgets`), permitiendo filtrar por mes y año.
-   [] Tarea 5: Implementar `updateBudget` (`PATCH /budgets/:id`).
-   [] Tarea 6: Implementar `deleteBudget` (`DELETE /budgets/:id`).
-   [] Tarea 7: Proteger todas las rutas y validar la propiedad del usuario en la lógica de servicio.

---

### **Fase 5: Lógica para `MonthlySummary` (Resumen Mensual)**

-   [] Tarea 1: Crear un endpoint de solo lectura `GET /summary/:year/:month` en el `FinanceController`.
-   [] Tarea 2: Implementar en `FinanceService` un método que calcule dinámicamente el resumen del mes consultado, obteniendo transacciones y presupuestos del usuario.
-   [] Tarea 3: La lógica debe calcular: total de ingresos, total de egresos, balance y gasto por categoría versus su presupuesto.
-   [] Tarea 4: Devolver el objeto de resumen calculado en la respuesta del endpoint.
-   [] Tarea 5: Proteger el endpoint con `JwtAuthGuard`.
